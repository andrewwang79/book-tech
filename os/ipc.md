# 进程间通信
* [Linux进程通信方式：pipe无名管道、fifo有名管道、共享内存映射、socket、消息队列](https://zhuanlan.zhihu.com/p/57454565)
* [semaphore和mutex](https://blog.csdn.net/zwan0518/article/details/8761000)：semaphore是多元信号量，mutex是锁(二元信号量)
* [Windows进程同步之互斥量内核对象](https://blog.csdn.net/iteye_18480/article/details/82514068)
* [windows进程通信-共享内存和信号量](https://blog.csdn.net/xihuanniNI/article/details/78958346)

## 共享内存
### 流程
* 定义：共享内存类**SM**，共享内存对象**SMO**，业务对象**BO**
* 需要转换的原因：业务对象不一定全部要传输，需要传输的数据有指针
* 生产时先创建共享内存后做转换的原因：如先做转换则无共享内存，相当于还要把转换后的结果再次拷贝到共享内存，增加耗时。

1. 生产
    1. 基于SM的size创建共享内存。获取SMO(映射到共享内存)
    1. BO转换成SM结构，保存到SMO
1. 消费
    1. 基于SM的size开通共享内存，从共享内存读取SMO
    1. 把SMO转换到BO

### 共享内存的类含指针的传输方案
> 核心难点是指针对应的地址不在共享内存上，所以只能通过数据传输

1. SM里没有指针，每个指针单独做成1个共享内存：消费者基于指针对应数据的size开通共享内存，通过void*获取指针数据
1. SM是1个共享内存，用固定size的数据(如数组)替代指针，注意size要满足最大需求

### 场景
* 说明：P是生产者，C是消费者
* C返回的对象建议用P提供的共享内存【C创建的共享内存回传给P很不方便】

| 场景 | 步骤 | 结果 | 说明 |
| :-: | - | - | - |
| 1 | P启动写内存(字符串+byte/地址)，P同步拉起C，C读内存并覆盖写内存 | P正常打印内存 |  |
| 2 | P启动写内存，P同步拉起C，C读内存并写新内存 | P正常打印新内存 |  |
| 3 | P启动写内存，P异步拉起C，P循环打印内存里进度并等待C的结束通知，C覆盖写内存(进度每秒10%)，C完成后发出结束通知 | P看到C成功结束 |  |
| 4 | P启动写内存，P同步拉起C，C异常退出 | P收到失败和异常信息 |  |
| 5 | P启动写内存，P同步拉起C，P异常退出，C读内存并覆盖写内存 | C正常完成 | C在P异常退出前已经打开共享内存，就可以一直读写共享内存 |
| 6 | P和C启动，P写内存并通知C执行任务X，C在执行完成后通知P任务X执行完成 | P看到X执行成功 |  |

* 部分伪码

```
3P：
while(1) {
  print(进度);
  if (C结束通知)
    break;
  sleep(100);
}
3C：
loop(10)
  写进度()
结束通知

6P：
通知C执行任务X
wait_signal(任务X执行完成);
```
